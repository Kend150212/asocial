/**
 * POST /api/setup/initialize — the "Finish" button endpoint.
 *
 * Performs all setup actions:
 * 1. Writes .env file
 * 2. Runs prisma migrate deploy
 * 3. Runs prisma db seed
 * 4. Creates admin user
 * 5. Installs crontab for cron jobs
 * 6. Writes setup lock file
 */

import { NextRequest, NextResponse } from 'next/server'
import { isSetupComplete, markSetupComplete } from '@/lib/setup-check'
import { randomBytes } from 'crypto'
import { writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs'
import { join } from 'path'
import { exec } from 'child_process'
import { promisify } from 'util'
import { hashSync } from 'bcryptjs'

const execAsync = promisify(exec)

export const dynamic = 'force-dynamic'
export const maxDuration = 120 // migrations can take time

export async function POST(req: NextRequest) {
    if (isSetupComplete()) {
        return NextResponse.json({ error: 'Setup already complete' }, { status: 403 })
    }

    const body = await req.json()
    const {
        // Step 1: Database
        dbHost = 'localhost',
        dbPort = '5432',
        dbName = 'asocial',
        dbUser = 'asocial',
        dbPassword,
        redisUrl = 'redis://localhost:6379',
        domain, // auto-detected or user override

        // Step 2: Admin
        adminName,
        adminEmail,
        adminPassword,

        // Step 3: Keys (auto-generated on frontend, sent here for .env)
        authSecret,
        encryptionKey,
        fbWebhookVerifyToken,
        cronSecret,
        workerSecret,
    } = body

    // ── Validate required fields ──────────────────────────────────
    if (!dbPassword) return NextResponse.json({ error: 'Database password is required' }, { status: 400 })
    if (!adminName || !adminEmail || !adminPassword) {
        return NextResponse.json({ error: 'Admin name, email, and password are required' }, { status: 400 })
    }
    if (!domain) return NextResponse.json({ error: 'Domain is required' }, { status: 400 })

    const steps: { step: string; status: string; error?: string }[] = []
    const projectDir = process.cwd()

    try {
        // ── Step 1: Write .env file ───────────────────────────────────
        const databaseUrl = `postgresql://${dbUser}:${encodeURIComponent(dbPassword)}@${dbHost}:${dbPort}/${dbName}?schema=public`

        const envContent = [
            '# ========================================',
            '# ASocial — Auto-generated by Setup Wizard',
            `# Generated at: ${new Date().toISOString()}`,
            '# ========================================',
            '',
            '# Database (PostgreSQL)',
            `DATABASE_URL="${databaseUrl}"`,
            '',
            '# Auth',
            `AUTH_SECRET="${authSecret}"`,
            `NEXTAUTH_URL="${domain}"`,
            '',
            '# Redis',
            `REDIS_URL="${redisUrl}"`,
            '',
            '# Encryption',
            `ENCRYPTION_KEY="${encryptionKey}"`,
            '',
            '# Cron & Worker secrets',
            `CRON_SECRET="${cronSecret}"`,
            `WORKER_SECRET="${workerSecret}"`,
            '',
            '# Facebook/Instagram Webhook',
            `FB_WEBHOOK_VERIFY_TOKEN="${fbWebhookVerifyToken}"`,
            '',
        ].join('\n')

        writeFileSync(join(projectDir, '.env'), envContent, 'utf-8')
        steps.push({ step: 'Write .env', status: 'success' })

        // Also save a backup in data/
        const dataDir = join(projectDir, 'data')
        if (!existsSync(dataDir)) mkdirSync(dataDir, { recursive: true })
        writeFileSync(join(dataDir, '.env.backup'), envContent, 'utf-8')

        // ── Step 2: Run Prisma DB Push ─────────────────────────────────
        try {
            // Use db push instead of migrate deploy — more forgiving,
            // doesn't fail on failed migration history (P3009)
            const migrateResult = await execAsync(
                `DATABASE_URL="${databaseUrl}" npx prisma db push --accept-data-loss`,
                { cwd: projectDir, timeout: 60000 }
            )
            steps.push({ step: 'Database migration', status: 'success' })
            console.log('[Setup] DB push output:', migrateResult.stdout)
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Migration failed'
            steps.push({ step: 'Database migration', status: 'error', error: msg })
            // Don't stop — might already be migrated
        }

        // ── Step 3: Run Prisma Seed ───────────────────────────────────
        try {
            const seedResult = await execAsync(
                `DATABASE_URL="${databaseUrl}" npx prisma db seed`,
                { cwd: projectDir, timeout: 60000 }
            )
            steps.push({ step: 'Database seed', status: 'success' })
            console.log('[Setup] Seed output:', seedResult.stdout)
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Seed failed'
            steps.push({ step: 'Database seed', status: 'error', error: msg })
        }

        // ── Step 4: Create Admin User ─────────────────────────────────
        try {
            // Re-import prisma with new DATABASE_URL
            // We use pg directly since prisma might still have old connection
            const { Client } = await import('pg')
            const client = new Client({ connectionString: databaseUrl })
            await client.connect()

            const hashedPassword = hashSync(adminPassword, 12)
            const id = randomBytes(12).toString('hex')

            // Check if admin already exists
            // Table is "users" (@@map), columns use snake_case (@map)
            const existing = await client.query(
                'SELECT id FROM users WHERE email = $1',
                [adminEmail]
            )

            if (existing.rows.length === 0) {
                await client.query(
                    `INSERT INTO users (id, name, email, password_hash, role, email_verified, created_at, updated_at)
                     VALUES ($1, $2, $3, $4, 'ADMIN', NOW(), NOW(), NOW())`,
                    [id, adminName, adminEmail, hashedPassword]
                )
                steps.push({ step: 'Create admin', status: 'success' })
            } else {
                steps.push({ step: 'Create admin', status: 'success', error: 'Admin already exists' })
            }

            await client.end()
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Failed to create admin'
            steps.push({ step: 'Create admin', status: 'error', error: msg })
        }

        // ── Step 5: Install Crontab ───────────────────────────────────
        try {
            // Read existing crontab
            let existingCrontab = ''
            try {
                const { stdout } = await execAsync('crontab -l 2>/dev/null')
                existingCrontab = stdout
            } catch {
                // No existing crontab
            }

            // Only add if not already present
            const cronLines = [
                `# ASocial cron jobs (auto-installed by setup wizard)`,
                `*/3 * * * * curl -s -H "x-cron-secret: ${cronSecret}" ${domain}/api/cron/poll-youtube-comments >/dev/null 2>&1`,
                `*/3 * * * * curl -s -H "x-cron-secret: ${cronSecret}" ${domain}/api/cron/poll-tiktok-comments >/dev/null 2>&1`,
            ]

            if (!existingCrontab.includes('asocial')) {
                const newCrontab = existingCrontab.trim() + '\n\n' + cronLines.join('\n') + '\n'
                // Write to temp file and install
                const tmpFile = join(projectDir, 'data', '.crontab-tmp')
                writeFileSync(tmpFile, newCrontab, 'utf-8')
                await execAsync(`crontab ${tmpFile}`)
                steps.push({ step: 'Install crontab', status: 'success' })
            } else {
                steps.push({ step: 'Install crontab', status: 'success', error: 'Already installed' })
            }
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Crontab installation failed'
            steps.push({ step: 'Install crontab', status: 'warning', error: msg })
            // Non-fatal — user can install manually
        }

        // ── Step 6: Restart PM2 ───────────────────────────────────────
        try {
            // Update PM2 env with new .env values
            await execAsync('pm2 restart all', { cwd: projectDir, timeout: 30000 })
            steps.push({ step: 'Restart PM2', status: 'success' })
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'PM2 restart failed'
            steps.push({ step: 'Restart PM2', status: 'warning', error: msg })
        }

        // ── Step 7: Write Lock File ───────────────────────────────────
        markSetupComplete({
            domain,
            adminEmail,
        })
        steps.push({ step: 'Lock setup', status: 'success' })

        return NextResponse.json({
            success: true,
            steps,
            message: 'Setup complete! Redirecting to login...',
        })

    } catch (err) {
        const msg = err instanceof Error ? err.message : 'Setup failed'
        return NextResponse.json({
            success: false,
            steps,
            error: msg,
        }, { status: 500 })
    }
}

/**
 * GET /api/setup/initialize — generate security keys
 */
export async function GET() {
    if (isSetupComplete()) {
        return NextResponse.json({ error: 'Setup already complete' }, { status: 403 })
    }

    return NextResponse.json({
        authSecret: randomBytes(32).toString('base64'),
        encryptionKey: randomBytes(32).toString('hex'),
        fbWebhookVerifyToken: randomBytes(16).toString('hex'),
        cronSecret: randomBytes(16).toString('hex'),
        workerSecret: randomBytes(16).toString('hex'),
    })
}
